// addons/addon-forge.js
// Safely scaffold new addons + prepare selfedit patches (write-fence compliant)

const fs = require("fs");
const path = require("path");

function kebab(s){return String(s||"").trim().toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");}
function routeLine(method,path){return `app.${method.toLowerCase()}("${path}", (req,res)=>{ res.json({ ok:true, forge:"${path}" }); });`}

function addonTemplate({ name, routes=[] }) {
  const lines = [];
  lines.push(`// addons/${name}.js`);
  lines.push(`// Generated by addon-forge â€” feel free to edit`);
  lines.push(``);
  lines.push(`function register(app) {`);
  if (routes.length === 0) {
    lines.push(`  app.get("/addon/${name}/ping", (_req,res)=> res.json({ ok:true, addon:"${name}" }));`);
  } else {
    for (const r of routes) {
      const m = (r.method||"get").toLowerCase();
      const p = r.path || `/addon/${name}/ping`;
      lines.push(`  ${routeLine(m,p)}`);
    }
  }
  lines.push(`  console.log("[addon:${name}] mounted");`);
  lines.push(`}`);
  lines.push(`module.exports = { register };`);
  lines.push(``);
  return lines.join("\n");
}

function buildProposal({ fileName, code }) {
  // Patch #1: create the addon file
  const p1 = {
    target: `addons/${fileName}`,
    action: "create",
    snippet: code
  };
  // Patch #2: enable in registry.json (insert object after the "addons": [ anchor)
  const p2 = {
    target: "addons/registry.json",
    action: "insertAfter",
    anchor: `"addons": [`,
    snippet: `\n    { "file": "${fileName}", "enabled": true },`
  };
  return {
    goal: `Scaffold and enable addon ${fileName}`,
    rationale: "Expand capabilities safely within write-fence.",
    patches: [p1, p2],
    tests: [
      { cmd: "node -e \"require('fs').readFileSync('addons/registry.json','utf8') && console.log('registry ok')\"", description: "registry.json readable" },
      { cmd: "node -e \"require('./addons/${fileName.replace(/"/g,'\\"')}') && console.log('addon loads')\"", description: "addon module loads" },
      { cmd: "npm run build", description: "client build (noop-safe) passes" }
    ],
    risk: "Low; only touches addons/** and registry.json formatting is preserved.",
    revert: "Remove created file and registry entry."
  };
}

function register(app) {
  // Quick health
  app.get("/addon/forge/health", (_req,res)=> res.json({ ok:true, forge:"ready" }));

  // POST /addon/forge/propose
  // body: { name: "my-addon", routes?: [{method:"get", path:"/addon/my-addon/hello"}] }
  app.post("/addon/forge/propose", expressJson, (req,res) => {
    try {
      const raw = String(req.body?.name || "");
      if (!raw) return res.status(400).json({ ok:false, error:"Missing name" });
      const name = kebab(raw);
      if (!name) return res.status(400).json({ ok:false, error:"Invalid name" });

      const fileName = `${name}.js`;
      const routes = Array.isArray(req.body?.routes) ? req.body.routes : [];
      const code = addonTemplate({ name, routes });

      const proposal = buildProposal({ fileName, code });
      return res.json({ ok:true, proposal, tip: "POST this to /selfedit/propose, then validate & approve." });
    } catch (e) {
      return res.status(500).json({ ok:false, error:String(e.message||e) });
    }
  });
}

function expressJson(req,res,next){
  if (req.is("application/json") || String(req.headers["content-type"]||"").includes("application/json")) {
    let body="";
    req.on("data",c=>body+=c);
    req.on("end",()=>{ try{ req.body = body? JSON.parse(body):{}; }catch{ req.body={}; } next(); });
  } else {
    // best-effort: empty body
    req.body = {};
    next();
  }
}

module.exports = { register };
